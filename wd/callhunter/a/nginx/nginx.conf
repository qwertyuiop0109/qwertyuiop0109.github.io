user  nginx;
worker_processes  2;
worker_priority -5;
worker_rlimit_nofile 100000;
error_log  /var/log/nginx/error.log crit;
pid        /var/run/nginx.pid;

events {
	worker_connections  50000;
	use epoll;
}

http {
	include       /etc/nginx/cloudflare;

	include       /etc/nginx/mime.types;
	default_type  application/octet-stream;
	log_format  main  '$remote_addr - $remote_user [$time_local] $scheme '
		'SERVER_ADDR $server_addr HOST $host "$request" $status $body_bytes_sent "$http_referer" '
		'"$http_user_agent" "http_x_forwarded_for"';

#	access_log  /var/log/nginx/access.log  main;
#После тестов и При большой посещаемости рекомендуется отключить логирование запросов access.log:
#указать access_log off; и закомментировать везде access_log /var/log/nginx/access.log  main;
	access_log off;



	perl_set $removeip '
	sub {
		my $r = shift;
		my $file="/var/log/503ips/".$r->remote_addr;
		unless (-f $file.".long") {
			unlink $file if -f $file;
			unlink $file.".midl" if -f $file.".midl";
		}
		return 1;
	}';



	perl_set $crc32_captchaimgfl '
	sub {
		use String::CRC32;
		my $r = shift;
		my $captchaimgfl=$r->uri;
		$captchaimgfl=~ s/.*\/captchaimgfl\/(.+)\.gif/$1/g;
		my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
		return crc32($captchaimgfl.$r->remote_addr."secret HjkYYkdmsG".$mday.$mon.$year);
	}';

	perl_set $crc32_ct '
	sub {
		use String::CRC32;
		my $r = shift;
		my $ct=$r->uri;
		$ct=~ s/.*\/icaptcha\/(.+)\.gif/$1/g;
		my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
		return crc32($ct.$r->remote_addr."secret Gl6HbvpxRR".$mday.$mon.$year);
	}';

	perl_set $check_input '
	sub {
		use String::CRC32;
		my $r = shift;
		my $input=$r->args;
		return 0 if $input!~ s/^.*input=(\w+).*$/$1/i;
		my $cookie_ct=$r->header_in("Cookie");
		$cookie_ct=~ s/.+ct=([^\ ]+).*/$1/g;
		my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
#		if ( $cookie_ct == crc32($input.$r->remote_addr."secret Gl6HbvpxRR".$mday.$mon.$year) ) { return 1; } else {return 0;}
		if ((-f "/home/nginx/icaptcha/".$input.".gif")&&( $cookie_ct == crc32($input.$r->remote_addr."secret Gl6HbvpxRR".$mday.$mon.$year) )) { return 1; } else {return 0;}
	}';

	perl_set $crc32_ha '
	sub {
		use String::CRC32;
		my $r = shift;
		return crc32($r->remote_addr."secret Gl6HbvpxQ");
	}';


	perl_set $check_ha '
	sub {
		use String::CRC32;
		my $r = shift;
		my $cookie_ha=$r->header_in("Cookie");
		$cookie_ha=~ s/.+ha=([^\ ]+).*/$1/g;
		if ( crc32($r->remote_addr."secret Gl6HbvpxQ") == $cookie_ha ) { return 1; } else {return 0;}
	}';


	perl_set $set503andcookie '
	sub {
		my $r = shift;
		my $uri=$r->uri;
		my $cookiehost=$r->header_in("Host");
		my $iphost=0;
		if ($cookiehost =~ /^(www\.)?\[?((([^\]]*\:[^\]]*\:[^\]]*)|([\d\.]+\.\d+))|([^\]\:]+[^\]\:\d]))\]?(:\d*)?$/i) {
			$cookiehost = $2;
			$iphost=$3;
		}
		$cookiehost = ".".$cookiehost if !$iphost;
		if ($r->args&&($r->request_method eq "GET")){
			$uri=$uri."?".$r->args;
		} 
		if ($r->request_method ne "POST") {
			$r->status(503);
		} else {
			$r->status(302);
		}
		$r->header_out("Set-Cookie","fu=".$uri."; path=/; domain=".$cookiehost);
		$r->header_out("Pragma","no-cache");
		$r->header_out("Cache-Control","private, max-age=0, no-cache");
		if ($r->request_method ne "POST") {
			$r->send_http_header("text/html");
		} else {
			$r->header_out("Location",$r->uri);
			$r->send_http_header;
			$r->flush;
		}
	        return 1;
	}';


	perl_set $set503andmaincookie '
	sub {
		my $r = shift;
		my $cookiehost=$r->header_in("Host");
		my $iphost=0;
		if ($cookiehost =~ /^(www\.)?\[?((([^\]]*\:[^\]]*\:[^\]]*)|([\d\.]+\.\d+))|([^\]\:]+[^\]\:\d]))\]?(:\d*)?$/i) {
			$cookiehost = $2;
			$iphost=$3;
		}
		$cookiehost = ".".$cookiehost if !$iphost;
		if ($r->request_method ne "POST") {
			$r->status(503);
		} else {
			$r->status(302);
		}
		$r->header_out("Set-Cookie","fu=/; path=/; domain=".$cookiehost);
		$r->header_out("Pragma","no-cache");
		$r->header_out("Cache-Control","private, max-age=0, no-cache");
		if ($r->request_method ne "POST") {
			$r->send_http_header("text/html");
		} else {
			$r->header_out("Location",$r->uri);
			$r->send_http_header;
			$r->flush;
		}
	        return 1;
	}';


	perl_set $set503withoutcookie '
	sub {
		my $r = shift;
		if ($r->request_method ne "POST") {
			$r->status(503);
		} else {
			$r->status(302);
		}
		$r->header_out("Pragma","no-cache");
		$r->header_out("Cache-Control","private, max-age=0, no-cache");
		if ($r->request_method ne "POST") {
			$r->send_http_header("text/html");
		} else {
			$r->header_out("Location",$r->uri);
			$r->send_http_header;
			$r->flush;
		}
	        return 1;
	}';


	perl_set $exploit '
	sub {
		my $r = shift;
		my $args=$r->args;
		if ($args) {
			if ($args =~ /((\%3D)|(=))[^\n]*((\%27)|(\')|(\-\-)|(\%3B)|(;)|(\%23)|(\#))/i) {
			        return 1;
			}
			if ($args =~ /((\%3D)|(=))[^\n]*((\%3C)|<)[^\n]+((\%3E)|>)/i) {
			        return 1;
			}
		}
	        return 0;
	}';


	sendfile        on;
	tcp_nopush     on;
	tcp_nodelay    on;

        reset_timedout_connection on;
        client_header_timeout  10;
        client_body_timeout    10;
        send_timeout            5;
        keepalive_timeout       0;

	server_tokens off;

#включаем gzip, в т.ч. для проксируемых ответов (этот блок ставим только для своих серверов, если нужно, так как доп.нагрузка на этот сервер)
#	gzip on;
#	gzip_min_length 1100;
#	gzip_disable "msie6";
#	gzip_proxied any;
#	gzip_comp_level 3;
#	gzip_types text/plain text/css application/x-javascript text/xml application/xml application/xml+rss text/javascript;
#	gzip_vary on;
#конец блока (для отключения закомментировать полностью)


limit_req_zone $binary_remote_addr zone=req_click:10m rate=1r/s;
limit_zone conn_click $binary_remote_addr  10m;
#limit_conn_zone $binary_remote_addr  zone=conn_click:10m;

limit_req_zone $binary_remote_addr zone=req_scriptonpage:10m rate=1r/s;
limit_zone conn_scriptonpage $binary_remote_addr  10m;
#limit_conn_zone $binary_remote_addr zone=conn_scriptonpage:10m;

limit_req_zone $binary_remote_addr zone=req_img:10m rate=1200r/m;
limit_zone conn_img $binary_remote_addr 10m;
#limit_conn_zone $binary_remote_addr zone=conn_img:10m;


proxy_cache_path /var/cache/nginx/cache levels=1:2 keys_zone=one:16m inactive=7d max_size=1024m;
proxy_temp_path /var/cache/nginx/temp;

	include setup.conf;

	server {
		listen 127.0.0.1;
		server_name localhost;
		location /nginx_status {
			stub_status on;
			access_log   off;
			allow 127.0.0.1;
			deny all;
		}
	}


}

